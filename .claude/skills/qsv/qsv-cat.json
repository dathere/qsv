{
  "name": "qsv-cat",
  "version": "12.0.0",
  "description": "Concatenate CSV files by row or by column. When concatenating by column, the columns will be written in the same order as the inputs given. The number of rows in the result is always equivalent to the minimum number of rows across all given CSV data. (This behavior can be reversed with the '--pad' flag.) Concatenating by rows can be done in two ways: 'rows' subcommand: All CSV data must have the same number of columns (unless --flexible is enabled) and in the same order. If you need to rearrange the columns or fix the lengths of records, use the 'select' or 'fixlengths' commands. Also, only the headers of the *first* CSV data given are used. Headers in subsequent inputs are ignored. (This behavior can be disabled with --no-headers.) 'rowskey' subcommand: CSV data can have different numbers of columns and in different orders. All columns are written in insertion order. If a column is missing in a row, an empty field is written. If a column is missing in the header, an empty field is written for all rows. For examples, see https://github.com/dathere/qsv/blob/master/tests/test_cat.rs.",
  "category": "utility",
  "command": {
    "binary": "qsv",
    "subcommand": "cat",
    "args": [
      {
        "name": "input",
        "type": "file",
        "required": true,
        "description": "...              The CSV file(s) to read. Use '-' for standard input. If input is a directory, all files in the directory will be read as input. If the input is a file with a '.infile-list' extension, the file will be read as a list of input files. If the input are snappy-compressed files(s), it will be decompressed automatically."
      }
    ],
    "options": [
      {
        "flag": "--delimiter",
        "type": "string",
        "description": "The field delimiter for reading CSV data. Must be a single character. (default: ,)"
      },
      {
        "flag": "--flexible",
        "type": "flag",
        "description": "When concatenating rows, this flag turns off validation that the input and output CSVs have the same number of columns. This is faster, but may result in invalid CSV data."
      },
      {
        "flag": "--group",
        "type": "string",
        "description": "When concatenating with rowskey, you can specify a grouping value which will be used as the first column in the output. This is useful when you want to know which file a row came from. Valid values are 'fullpath', 'parentdirfname', 'parentdirfstem', 'fname', 'fstem' and 'none'. A new column will be added to the beginning of each row using --group-name. If 'none' is specified, no grouping column will be added. [default: none]",
        "default": "none"
      },
      {
        "flag": "--group-name",
        "type": "string",
        "description": "When concatenating with rowskey, this flag provides the name for the new grouping column. [default: file]",
        "default": "file"
      },
      {
        "flag": "--help",
        "type": "flag",
        "description": "Display this message"
      },
      {
        "flag": "--no-headers",
        "type": "flag",
        "description": "When set, the first row will NOT be interpreted as column names. Note that this has no effect when concatenating columns."
      },
      {
        "flag": "--output",
        "type": "string",
        "description": "Write output to <file> instead of stdout."
      },
      {
        "flag": "--pad",
        "type": "flag",
        "description": "When concatenating columns, this flag will cause all records to appear. It will pad each row if other CSV data isn't long enough."
      }
    ]
  },
  "examples": [],
  "hints": {
    "streamable": true,
    "memory": "constant"
  },
  "test_file": "https://github.com/dathere/qsv/blob/master/tests/test_cat.rs"
}