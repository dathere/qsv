{
  "name": "qsv-fetchpost",
  "version": "14.0.0",
  "description": "Similar to `fetch`, but uses **HTTP Post** (HTTP GET vs POST methods). Supports HTML form (application/x-www-form-urlencoded), JSON (application/json) and custom content types - with the ability to render payloads using CSV data using the Mini Jinja template engine.",
  "category": "utility",
  "command": {
    "binary": "qsv",
    "subcommand": "fetchpost",
    "args": [
      {
        "name": "url-column",
        "type": "string",
        "required": true,
        "description": "Name of the column with the URL. Otherwise, if the argument starts with `http`, the URL to use."
      },
      {
        "name": "column-list",
        "type": "regex",
        "required": true,
        "description": "Comma-delimited list of columns to insert into the HTTP Post body. Uses `qsv select` syntax - i.e. Columns can be referenced by index or by name if there is a header row (duplicate column names can be disambiguated with more indexing). Column ranges can also be specified. Finally, columns can be selected using regular expressions. See 'qsv select --help' for examples."
      },
      {
        "name": "input",
        "type": "file",
        "required": true,
        "description": ""
      }
    ],
    "options": [
      {
        "flag": "--cache-error",
        "type": "flag",
        "description": "Cache error responses even if a request fails. If an identical URL is requested, the cached error is returned. Otherwise, the fetch is attempted again for --max-retries."
      },
      {
        "flag": "--compress",
        "type": "flag",
        "description": "Compress the HTTP request body using gzip. Note that most servers do not support compressed request bodies unless they are specifically configured to do so. This should only be enabled for trusted scenarios where \"zip bombs\" are not a concern. see https://github.com/postmanlabs/httpbin/issues/577#issuecomment-875814469 for more info."
      },
      {
        "flag": "--content-type",
        "type": "string",
        "description": "Overrides automatic content types for `<column-list>` (`application/x-www-form-urlencoded`) and `--payload-tpl` (`application/json`). Typical alternative values are `multipart/form-data` and `text/plain`. It is the responsibility of the user to format the payload accordingly when using --payload-tpl."
      },
      {
        "flag": "--cookies",
        "type": "flag",
        "description": "Allow cookies."
      },
      {
        "flag": "--delimiter",
        "type": "string",
        "description": "The field delimiter for reading CSV data. Must be a single character. (default: ,)"
      },
      {
        "flag": "--disk-cache",
        "type": "flag",
        "description": "Use a persistent disk cache for responses. The cache is stored in the directory specified by --disk-cache-dir. If the directory does not exist, it will be created. If the directory exists, it will be used as is. It has a default Time To Live (TTL)/lifespan of 28 days and cache hits do not refresh the TTL of cached values. Adjust the QSV_DISKCACHE_TTL_SECS & QSV_DISKCACHE_TTL_REFRESH env vars to change DiskCache settings."
      },
      {
        "flag": "--disk-cache-dir",
        "type": "string",
        "description": "The directory <dir> to store the disk cache. Note that if the directory does not exist, it will be created. If the directory exists, it will be used as is, and will not be flushed. This option allows you to maintain several disk caches for different fetchpost jobs (e.g. one for geocoding, another for weather, etc.)",
        "default": "~/.qsv/cache/fetchpost"
      },
      {
        "flag": "--flush-cache",
        "type": "flag",
        "description": "Flush all the keys in the current cache on startup. This only applies to Disk and Redis caches."
      },
      {
        "flag": "--globals-json",
        "type": "string",
        "description": "A JSON file containing global variables. When posting as an HTML Form, this file is added to the Form data. When constructing a payload using a MiniJinja template, the JSON properties can be accessed in templates using the \"qsv_g\" namespace (e.g. {{qsv_g.api_key}}, {{qsv_g.base_url}})."
      },
      {
        "flag": "--help",
        "type": "flag",
        "description": "Display this message"
      },
      {
        "flag": "--http-header",
        "type": "string",
        "description": "Append custom header(s) to the HTTP header. Pass multiple key-value pairs by adding this option multiple times, once for each pair. The key and value should be separated by a colon."
      },
      {
        "flag": "--jaq",
        "type": "string",
        "description": "Apply jaq selector to API returned JSON response. Mutually exclusive with --jaqfile."
      },
      {
        "flag": "--jaqfile",
        "type": "string",
        "description": "Load jaq selector from file instead. Mutually exclusive with --jaq."
      },
      {
        "flag": "--max-errors",
        "type": "string",
        "description": "Maximum number of errors before aborting. Set to zero (0) to continue despite errors.",
        "default": "10"
      },
      {
        "flag": "--max-retries",
        "type": "string",
        "description": "Maximum number of retries per record before an error is raised.",
        "default": "5"
      },
      {
        "flag": "--mem-cache-size",
        "type": "string",
        "description": "Maximum number of entries in the in-memory LRU cache.",
        "default": "2000000"
      },
      {
        "flag": "--new-column",
        "type": "string",
        "description": "Put the fetched values in a new column. Specifying this option results in a CSV. Otherwise, the output is in JSONL format."
      },
      {
        "flag": "--no-cache",
        "type": "flag",
        "description": "Do not cache responses."
      },
      {
        "flag": "--no-headers",
        "type": "flag",
        "description": "When set, the first row will not be interpreted as headers. Namely, it will be sorted with the rest of the rows. Otherwise, the first row will always appear as the header row in the output."
      },
      {
        "flag": "--output",
        "type": "string",
        "description": "Write output to <file> instead of stdout."
      },
      {
        "flag": "--payload-tpl",
        "type": "string",
        "description": "Instead of <column-list>, use a MiniJinja template file to render a JSON payload in the HTTP Post body. You can also use --payload-tpl to render a non-JSON payload, but --content-type will have to be set manually. If a rendered JSON is invalid, `fetchpost` will abort and return an error."
      },
      {
        "flag": "--pretty",
        "type": "flag",
        "description": "Prettify JSON responses. Otherwise, they're minified. If the response is not in JSON format, it's passed through unchanged. Note that --pretty requires the --new-column option."
      },
      {
        "flag": "--progressbar",
        "type": "flag",
        "description": "Show progress bars. Will also show the cache hit rate upon completion. Not valid for stdin."
      },
      {
        "flag": "--rate-limit",
        "type": "string",
        "description": "Rate Limit in Queries Per Second (max: 1000). Note that fetch dynamically throttles as well based on rate-limit and retry-after response headers. Set to 0 to go as fast as possible, automatically throttling as required. CAUTION: Only use zero for APIs that use RateLimit and/or Retry-After headers, otherwise your fetchpost job may look like a Denial Of Service attack. Even though zero is the default, this is mitigated by --max-errors having a default of 10.",
        "default": "0"
      },
      {
        "flag": "--redis-cache",
        "type": "flag",
        "description": "Use Redis to cache responses. It connects to \"redis://127.0.0.1:6379/2\" with a connection pool size of 20, with a TTL of 28 days, and a cache hit NOT renewing an entry's TTL. Adjust the QSV_FP_REDIS_CONNSTR, QSV_REDIS_MAX_POOL_SIZE, QSV_REDIS_TTL_SECONDS & QSV_REDIS_TTL_REFRESH respectively to change Redis settings."
      },
      {
        "flag": "--report",
        "type": "string",
        "description": "Creates a report of the fetchpost job. The report has the same name as the input file with the \".fetchpost-report\" suffix. There are two kinds of report - d for \"detailed\" & s for \"short\". The detailed report has the same columns as the input CSV with seven additional columns - qsv_fetchp_url, qsv_fetchp_form, qsv_fetchp_status, qsv_fetchp_cache_hit, qsv_fetchp_retries, qsv_fetchp_elapsed_ms & qsv_fetchp_response. The short report only has the seven columns without the \"qsv_fetchp_\" prefix.",
        "default": "none"
      },
      {
        "flag": "--store-error",
        "type": "flag",
        "description": "On error, store error code/message instead of blank value."
      },
      {
        "flag": "--timeout",
        "type": "string",
        "description": "Timeout for each URL request.",
        "default": "30"
      },
      {
        "flag": "--user-agent",
        "type": "string",
        "description": "Specify custom user agent. It supports the following variables - $QSV_VERSION, $QSV_TARGET, $QSV_BIN_NAME, $QSV_KIND and $QSV_COMMAND. Try to follow the syntax here - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent"
      }
    ]
  },
  "hints": {
    "streamable": true,
    "indexed": true,
    "memory": "constant"
  }
}