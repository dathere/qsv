{
  "name": "qsv-validate",
  "version": "14.0.0",
  "description": "Validate CSV data _blazingly-fast_ using JSON Schema Validation (Draft 2020-12) (e.g. _up to 780,031 rows/second_[^1] using NYC's 311 schema generated by the `schema` command) & put invalid records into a separate file along with a detailed validation error report. Supports several custom JSON Schema formats & keywords: * `currency` custom format with ISO-4217 validation * `dynamicEnum` custom keyword that supports enum validation against a CSV on the filesystem or a URL (http/https/ckan & dathere URL schemes supported) * `uniqueCombinedWith` custom keyword to validate uniqueness across multiple columns for composite key validation. If no JSON schema file is provided, validates if a CSV conforms to the RFC 4180 standard and is UTF-8 encoded.",
  "category": "validation",
  "command": {
    "binary": "qsv",
    "subcommand": "validate",
    "args": [
      {
        "name": "subcommand",
        "type": "string",
        "required": false,
        "description": "Subcommand to execute. Valid values: schema",
        "enum": [
          "schema"
        ]
      },
      {
        "name": "json-schema",
        "type": "string",
        "required": true,
        "description": "JSON Schema file to validate against. If not provided, `validate` will run in RFC 4180 validation mode. The file can be a local file or a URL (http and https schemes supported)."
      }
    ],
    "options": [
      {
        "flag": "---------------------------------------",
        "type": "flag",
        "description": ""
      },
      {
        "flag": "-------------------------------------------------------",
        "type": "flag",
        "description": ""
      },
      {
        "flag": "--backtrack-limit",
        "type": "string",
        "description": "Set the approximate number of backtracking steps allowed. This is only used when --fancy-regex is set.",
        "default": "1000000"
      },
      {
        "flag": "--batch",
        "type": "string",
        "description": "The number of rows per batch to load into memory, before running in parallel. Automatically determined for CSV files with more than 50000 rows. Set to 0 to load all rows in one batch. Set to 1 to force batch optimization even for files with less than 50000 rows.",
        "default": "50000"
      },
      {
        "flag": "--cache-dir",
        "type": "string",
        "description": "The directory to use for caching downloaded dynamicEnum resources. If the directory does not exist, qsv will attempt to create it. If the QSV_CACHE_DIR envvar is set, it will be used instead. Not available on qsvlite.",
        "default": "~/.qsv-cache"
      },
      {
        "flag": "--ckan-api",
        "type": "string",
        "description": "The URL of the CKAN API to use for downloading dynamicEnum resources with the \"ckan://\" scheme. If the QSV_CKAN_API envvar is set, it will be used instead. Not available on qsvlite.",
        "default": "https://data.dathere.com/api/3/action"
      },
      {
        "flag": "--delimiter",
        "type": "string",
        "description": "The field delimiter for reading CSV data. Must be a single character."
      },
      {
        "flag": "--dfa-size-limit",
        "type": "string",
        "description": "Set the approximate capacity, in megabytes, of the cache of transitions used by the engine's lazy Discrete Finite Automata.",
        "default": "10"
      },
      {
        "flag": "--email-display-text",
        "type": "flag",
        "description": "Allow display text in emails. e.g. \"John Doe <john.doe@example.com>\" is INVALID if this option is NOT set."
      },
      {
        "flag": "--email-domain-literal",
        "type": "flag",
        "description": "Allow domain literals in emails. e.g. \"john.doe@[127.0.0.1]\" is VALID if this option is set."
      },
      {
        "flag": "--email-min-subdomains",
        "type": "string",
        "description": "Minimum number of subdomains required in the email. e.g. \"jdoe@example.com\" is INVALID if this option is set to 3, but \"jdoe@sub.example.com\" is VALID.",
        "default": "2"
      },
      {
        "flag": "--email-required-tld",
        "type": "flag",
        "description": "Require the email to have a valid Top-Level Domain (TLD) (e.g. .com, .org, .net, etc.). e.g. \"john.doe@example\" is VALID if this option is NOT set."
      },
      {
        "flag": "--fail-fast",
        "type": "flag",
        "description": "Stops on first error."
      },
      {
        "flag": "--fancy-regex",
        "type": "flag",
        "description": "Use the fancy regex engine instead of the default regex engine for validation. The fancy engine supports advanced regex features such as lookaround and backreferences, but is not as performant as the default regex engine which guarantees linear-time matching, prevents DoS attacks, and is more efficient for simple patterns."
      },
      {
        "flag": "--invalid",
        "type": "string",
        "description": "Invalid record output file suffix.",
        "default": "invalid"
      },
      {
        "flag": "--json",
        "type": "flag",
        "description": "When validating without a JSON Schema, return the RFC 4180 check as a JSON file instead of a message."
      },
      {
        "flag": "--no-format-validation",
        "type": "flag",
        "description": "Disable JSON Schema format validation. Ignores all JSON Schema \"format\" keywords (e.g. date,email, uri, currency, etc.). This is useful when you want to validate the structure of the CSV file w/o worrying about the data types and domain/range of the fields."
      },
      {
        "flag": "--no-headers",
        "type": "flag",
        "description": "When set, the first row will not be interpreted as headers. It will be validated with the rest of the rows. Otherwise, the first row will always appear as the header row in the output. Note that this option is only valid when running in RFC 4180 validation mode as JSON Schema validation requires headers."
      },
      {
        "flag": "--pretty-json",
        "type": "flag",
        "description": "Same as --json, but pretty printed."
      },
      {
        "flag": "--size-limit",
        "type": "string",
        "description": "Set the approximate size limit, in megabytes, of a compiled regex.",
        "default": "50"
      },
      {
        "flag": "--timeout",
        "type": "string",
        "description": "Timeout for downloading json-schemas on URLs and for 'dynamicEnum' lookups on URLs. If 0, no timeout is used.",
        "default": "30"
      },
      {
        "flag": "--trim",
        "type": "flag",
        "description": "Trim leading and trailing whitespace from fields before validating."
      },
      {
        "flag": "--valid",
        "type": "string",
        "description": "Valid record output file suffix.",
        "default": "valid"
      },
      {
        "flag": "--valid-output",
        "type": "string",
        "description": "Change validation mode behavior so if ALL rows are valid, to pass it to output, return exit code 1, and set stderr to the number of valid rows. Setting this will override the default behavior of creating a valid file only when there are invalid records. To send valid records to stdout, use `-` as the filename."
      }
    ]
  },
  "hints": {
    "streamable": true,
    "indexed": true,
    "memory": "constant"
  },
  "examples": [
    {
      "description": "Validate a CSV file. Use this to check if a CSV file is readable by qsv.",
      "command": "qsv validate data.csv"
    },
    {
      "description": "Validate a TSV file against a JSON Schema",
      "command": "qsv validate data.tsv schema.json"
    },
    {
      "description": "Validate multiple CSV files using various dialects against a JSON Schema",
      "command": "qsv validate data1.csv data2.tab data3.ssv schema.json"
    },
    {
      "description": "Validate all CSV files in a directory against a JSON Schema",
      "command": "qsv validate /path/to/csv_directory schema.json"
    },
    {
      "description": "Validate CSV files listed in a '.infile-list' file against a JSON Schema",
      "command": "qsv validate files.infile-list schema.json"
    }
  ]
}