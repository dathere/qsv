Generated using the command:
```bash
QSV_LLM_BASE_URL=http://localhost:1234/v1 QSV_DESCRIBEGPT_DB_ENGINE=/opt/homebrew/bin/duckdb \
qsv describegpt /tmp/NYC_311_SR_2010-2020-sample-1M.csv --output nyc311-describegpt-prompt.md \
--sql-results nyc311-describegpt-prompt.md \
--prompt "What are the top 10 complaint types per community board and borough?" \
--addl-props '{"reasoning_effort": "high"}'
```
---
```sql
-- Generated by qsv's describegpt command using openai/gpt-oss-20b on 2025-08-28T04:14:35.169754+00:00

/* 
   Top‑10 complaint types per Community Board and per Borough.
   Uses a common base table that counts complaints, then applies a window
   function to rank the complaint types within each group.  
*/

WITH base AS (
    SELECT 
        /* Fields from the CSV – column names are case‑sensitive */
        "Community Board",
        "Borough",
        "Complaint Type",
        COUNT(*) AS cnt
    FROM read_csv_auto('/tmp/NYC_311_SR_2010-2020-sample-1M.csv')
    GROUP BY 1,2,3
),

rank_cb AS (                -- ranking per Community Board
    SELECT 
        'Community Board'      AS grouping_type,
        "Community Board"     AS grouping_value,
        "Complaint Type",
        cnt,
        ROW_NUMBER() OVER (
            PARTITION BY "Community Board"
            ORDER BY cnt DESC
        )                      AS rn
    FROM base
),

rank_bor AS (                -- ranking per Borough
    SELECT 
        'Borough'             AS grouping_type,
        "Borough"             AS grouping_value,
        "Complaint Type",
        cnt,
        ROW_NUMBER() OVER (
            PARTITION BY "Borough"
            ORDER BY cnt DESC
        )                      AS rn
    FROM base
)

-- Combine the two rankings, keeping only the top 10 per group
SELECT grouping_type,
       grouping_value,
       "Complaint Type"   AS complaint_type,
       cnt
FROM rank_cb
WHERE rn <= 10

UNION ALL

SELECT grouping_type,
       grouping_value,
       "Complaint Type"   AS complaint_type,
       cnt
FROM rank_bor
WHERE rn <= 10

ORDER BY grouping_type,      -- Community Board first, then Borough
         grouping_value,
         cnt DESC;
```

## REASONING

The user asks: "What are the top 10 complaint types per community board and borough?" The dataset includes fields Community Board and Borough, Complaint Type. They want top 10 complaint types per each community board and per each borough.

We need to generate a SQL query that returns that. Should use read_csv table function with placeholder '/tmp/NYC_311_SR_2010-2020-sample-1M.csv'. Use DuckDB v1.0 syntax. We can join or group by both fields.

We should output the top 10 complaint types per Community Board and per Borough. Possibly two separate queries? Or combine into one result set with a grouping column indicating type of grouping.

Simplest: produce two result sets, maybe using UNION ALL. But better to produce single query that returns columns: grouping_type (CommunityBoard or Borough), group_value, complaint_type, count. Order by grouping_type, group_value, count desc limit 10 per group. In DuckDB, we can use window functions row_number partitioned by grouping and complaint type? Actually we want top 10 complaint types per community board, so we need to rank within each community board. Similarly for borough.

We could do: SELECT 'Community Board' as group_type, Community_Board as group_value, Complaint_Type, cnt FROM (...) WHERE rn <=10 UNION ALL SELECT 'Borough', Borough, Complaint_Type, cnt FROM (...) WHERE rn<=10

Where the subquery calculates counts and row_number partitioned by community board or borough.

Need to handle null values? But top 10 per group ignoring null. Could treat null as a value.

The query should read CSV: use read_csv_auto('/tmp/NYC_311_SR_2010-2020-sample-1M.csv').

So final SQL:

```
-- GENERATED_BY_SIGNATURE
WITH base AS (
    SELECT 
        Community_Board,
        Borough,
        "Complaint Type",
        COUNT(*) AS cnt
    FROM read_csv_auto('/tmp/NYC_311_SR_2010-2020-sample-1M.csv')
    GROUP BY 1,2,3
),
rank_cb AS (
    SELECT
        'Community Board' AS group_type,
        Community_Board AS group_value,
        "Complaint Type",
        cnt,
        ROW_NUMBER() OVER (PARTITION BY Community_Board ORDER BY cnt DESC) AS rn
    FROM base
),
rank_bor AS (
    SELECT
        'Borough' AS group_type,
        Borough AS group_value,
        "Complaint Type",
        cnt,
        ROW_NUMBER() OVER (PARTITION BY Borough ORDER BY cnt DESC) AS rn
    FROM base
)
SELECT * FROM rank_cb WHERE rn <= 10
UNION ALL
SELECT * FROM rank_bor WHERE rn <= 10
ORDER BY group_type, group_value, cnt DESC;
```

But need to ensure column names consistent. We can alias final columns as grouping_type, grouping_value, complaint_type, count.

Better produce:

```
WITH base AS (...),
rank_cb AS (...),
rank_bor AS (...)
SELECT grouping_type, grouping_value, complaint_type, cnt
FROM rank_cb WHERE rn <=10
UNION ALL
SELECT grouping_type, grouping_value, complaint_type, cnt
FROM rank_bor WHERE rn <=10
ORDER BY grouping_type, grouping_value, cnt DESC;
```

But need to alias properly.

Also we can use read_csv_auto('/tmp/NYC_311_SR_2010-2020-sample-1M.csv') or read_csv('/tmp/NYC_311_SR_2010-2020-sample-1M.csv', ...). The dataset may have header. Use read_csv_auto for simplicity.

Let's produce final query accordingly.




