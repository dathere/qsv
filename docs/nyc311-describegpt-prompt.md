```sql
-- Generated by qsv's describegpt command using openai/gpt-oss-20b on 2025-08-26T16:25:09.580716+00:00
-- This query computes the number of complaints for each combination of:
--   • borough (NYC borough)
--   • complaint type (high‑level category)
--   • year of creation
--
-- It reads the raw CSV via DuckDB's read_csv function and uses DATE_PART to extract
-- the year from the "Created Date" column.  Rows with missing Borough or Complaint
-- Type are excluded so that only meaningful groups appear in the result.
SELECT 
    DATE_PART('YEAR', "Created Date") AS year,
    "Borough",
    "Complaint Type",
    COUNT(*) AS complaint_count
FROM read_csv('/tmp/NYC_311_SR_2010-2020-sample-1M.csv')
WHERE "Borough" IS NOT NULL AND "Complaint Type" IS NOT NULL
GROUP BY 1,2,3
ORDER BY year, "Borough", complaint_count DESC;
```
/* Reasoning:
We need to answer user prompt: "What is the breakdown of complaint types by borough by year?" We can use summary stats and frequency distributions. They provide Complaint Type frequencies overall but not per borough or year. Frequency distribution doesn't include year dimension. But we have Created Date with counts; also Borough distribution. Need breakdown by borough by year: need to aggregate count of complaints for each (year, borough, complaint type). This requires SQL query using data table.

We cannot compute from summary stats alone because we don't have cross-tabulated frequencies. So we generate a SQL query that reads CSV and calculates this breakdown.

Need to use DuckDB syntax, read_csv function with placeholder '/tmp/NYC_311_SR_2010-2020-sample-1M.csv'. Provide comments explaining.

Also we must include comment with placeholder "GENERATED_BY_SIGNATURE" at top.

We also need to consider that Created Date is datetime; extract year. Use strftime or date_part. In DuckDB, you can use strftime or DATE_TRUNC? Actually DuckDB has function `date_trunc`, but easier: use `strftime("%Y", "Created Date")` cast to integer.

Then group by borough, complaint type, year. Count(*). Order maybe by year, borough, count desc.

We must consider missing values; maybe we can filter out nulls for Borough or Complaint Type? But include them if needed.

Also ensure we refer to column names with double quotes. For example "Complaint Type", "Borough", "Created Date".

Return SQL query as code block preceded by newline. Include comment at top with placeholder GENERATED_BY_SIGNATURE.

Let's craft:

```
-- GENERATED_BY_SIGNATURE
SELECT 
    CAST(strftime("%Y", "Created Date") AS INTEGER) AS year,
    "Borough",
    "Complaint Type",
    COUNT(*) AS complaint_count
FROM read_csv('/tmp/NYC_311_SR_2010-2020-sample-1M.csv')
WHERE "Borough" IS NOT NULL AND "Complaint Type" IS NOT NULL
GROUP BY 1,2,3
ORDER BY year, "Borough", complaint_count DESC;
```

But maybe we want to format year as integer; use date_part? In DuckDB: `datepart('year', "Created Date")`. Let's use that. Also cast.

So:

```
SELECT 
    DATE_PART('YEAR', "Created Date") AS year,
    "Borough",
    "Complaint Type",
    COUNT(*) AS complaint_count
FROM read_csv('/tmp/NYC_311_SR_2010-2020-sample-1M.csv')
WHERE "Borough" IS NOT NULL AND "Complaint Type" IS NOT NULL
GROUP BY 1,2,3
ORDER BY year, "Borough", complaint_count DESC;
```

Add comments explaining each step.

Return as code block.
*/

